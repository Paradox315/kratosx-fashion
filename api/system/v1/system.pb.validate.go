// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/system/v1/system.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on EmptyRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmptyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmptyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmptyRequestMultiError, or
// nil if none found.
func (m *EmptyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EmptyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyRequestMultiError(errors)
	}

	return nil
}

// EmptyRequestMultiError is an error wrapping multiple validation errors
// returned by EmptyRequest.ValidateAll() if the designated constraints aren't met.
type EmptyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyRequestMultiError) AllErrors() []error { return m }

// EmptyRequestValidationError is the validation error returned by
// EmptyRequest.Validate if the designated constraints aren't met.
type EmptyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyRequestValidationError) ErrorName() string { return "EmptyRequestValidationError" }

// Error satisfies the builtin error interface
func (e EmptyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmptyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyRequestValidationError{}

// Validate checks the field values on RegisterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequestMultiError, or nil if none found.
func (m *RegisterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RegisterRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := RegisterRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RegisterRequest_Password_Pattern.MatchString(m.GetPassword()) {
		err := RegisterRequestValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^[a-zA-Z]\\\\w{5,17}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = RegisterRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetMobile()) > 11 {
		err := RegisterRequestValidationError{
			field:  "Mobile",
			reason: "value length must be at most 11 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RegisterRequest_Mobile_Pattern.MatchString(m.GetMobile()) {
		err := RegisterRequestValidationError{
			field:  "Mobile",
			reason: "value does not match regex pattern \"^1(3|4|5|6|7|8|9)\\\\d{9}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCaptcha()) > 6 {
		err := RegisterRequestValidationError{
			field:  "Captcha",
			reason: "value length must be at most 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CaptchaId

	if len(errors) > 0 {
		return RegisterRequestMultiError(errors)
	}

	return nil
}

func (m *RegisterRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *RegisterRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// RegisterRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequestMultiError) AllErrors() []error { return m }

// RegisterRequestValidationError is the validation error returned by
// RegisterRequest.Validate if the designated constraints aren't met.
type RegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequestValidationError) ErrorName() string { return "RegisterRequestValidationError" }

// Error satisfies the builtin error interface
func (e RegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequestValidationError{}

var _RegisterRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{4,15}$")

var _RegisterRequest_Password_Pattern = regexp.MustCompile("^[a-zA-Z]\\w{5,17}$")

var _RegisterRequest_Mobile_Pattern = regexp.MustCompile("^1(3|4|5|6|7|8|9)\\d{9}$")

// Validate checks the field values on RetrieveRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RetrieveRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetrieveRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetrieveRequestMultiError, or nil if none found.
func (m *RetrieveRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RetrieveRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RetrieveRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := RetrieveRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCaptcha()) > 6 {
		err := RetrieveRequestValidationError{
			field:  "Captcha",
			reason: "value length must be at most 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CaptchaId

	if len(errors) > 0 {
		return RetrieveRequestMultiError(errors)
	}

	return nil
}

// RetrieveRequestMultiError is an error wrapping multiple validation errors
// returned by RetrieveRequest.ValidateAll() if the designated constraints
// aren't met.
type RetrieveRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetrieveRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetrieveRequestMultiError) AllErrors() []error { return m }

// RetrieveRequestValidationError is the validation error returned by
// RetrieveRequest.Validate if the designated constraints aren't met.
type RetrieveRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetrieveRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetrieveRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetrieveRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetrieveRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetrieveRequestValidationError) ErrorName() string { return "RetrieveRequestValidationError" }

// Error satisfies the builtin error interface
func (e RetrieveRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetrieveRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetrieveRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetrieveRequestValidationError{}

var _RetrieveRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{4,15}$")

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_LoginRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := LoginRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_LoginRequest_Password_Pattern.MatchString(m.GetPassword()) {
		err := LoginRequestValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^[a-zA-Z]\\\\w{5,17}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCaptcha()) > 6 {
		err := LoginRequestValidationError{
			field:  "Captcha",
			reason: "value length must be at most 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CaptchaId

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

var _LoginRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{4,15}$")

var _LoginRequest_Password_Pattern = regexp.MustCompile("^[a-zA-Z]\\w{5,17}$")

// Validate checks the field values on UserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserRequestMultiError, or
// nil if none found.
func (m *UserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UserRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := UserRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UserRequest_Password_Pattern.MatchString(m.GetPassword()) {
		err := UserRequestValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^[a-zA-Z]\\\\w{5,17}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Avatar

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = UserRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhone()) > 11 {
		err := UserRequestValidationError{
			field:  "Phone",
			reason: "value length must be at most 11 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UserRequest_Phone_Pattern.MatchString(m.GetPhone()) {
		err := UserRequestValidationError{
			field:  "Phone",
			reason: "value does not match regex pattern \"^1(3|4|5|6|7|8|9)\\\\d{9}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Nickname

	// no validation rules for Status

	for idx, item := range m.GetUserRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserRequestValidationError{
						field:  fmt.Sprintf("UserRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserRequestValidationError{
						field:  fmt.Sprintf("UserRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserRequestValidationError{
					field:  fmt.Sprintf("UserRoles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserRequestMultiError(errors)
	}

	return nil
}

func (m *UserRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *UserRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UserRequestMultiError is an error wrapping multiple validation errors
// returned by UserRequest.ValidateAll() if the designated constraints aren't met.
type UserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRequestMultiError) AllErrors() []error { return m }

// UserRequestValidationError is the validation error returned by
// UserRequest.Validate if the designated constraints aren't met.
type UserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRequestValidationError) ErrorName() string { return "UserRequestValidationError" }

// Error satisfies the builtin error interface
func (e UserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRequestValidationError{}

var _UserRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{4,15}$")

var _UserRequest_Password_Pattern = regexp.MustCompile("^[a-zA-Z]\\w{5,17}$")

var _UserRequest_Phone_Pattern = regexp.MustCompile("^1(3|4|5|6|7|8|9)\\d{9}$")

// Validate checks the field values on IDRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IDRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IDRequestMultiError, or nil
// if none found.
func (m *IDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return IDRequestMultiError(errors)
	}

	return nil
}

// IDRequestMultiError is an error wrapping multiple validation errors returned
// by IDRequest.ValidateAll() if the designated constraints aren't met.
type IDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IDRequestMultiError) AllErrors() []error { return m }

// IDRequestValidationError is the validation error returned by
// IDRequest.Validate if the designated constraints aren't met.
type IDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IDRequestValidationError) ErrorName() string { return "IDRequestValidationError" }

// Error satisfies the builtin error interface
func (e IDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IDRequestValidationError{}

// Validate checks the field values on PasswordRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PasswordRequestMultiError, or nil if none found.
func (m *PasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OldPassword

	// no validation rules for NewPassword

	if len(errors) > 0 {
		return PasswordRequestMultiError(errors)
	}

	return nil
}

// PasswordRequestMultiError is an error wrapping multiple validation errors
// returned by PasswordRequest.ValidateAll() if the designated constraints
// aren't met.
type PasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordRequestMultiError) AllErrors() []error { return m }

// PasswordRequestValidationError is the validation error returned by
// PasswordRequest.Validate if the designated constraints aren't met.
type PasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordRequestValidationError) ErrorName() string { return "PasswordRequestValidationError" }

// Error satisfies the builtin error interface
func (e PasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordRequestValidationError{}

// Validate checks the field values on ListRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListRequestMultiError, or
// nil if none found.
func (m *ListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	if m.GetPageSize() > 50 {
		err := ListRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 50",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRequestValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRequestValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRequestValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRequestMultiError(errors)
	}

	return nil
}

// ListRequestMultiError is an error wrapping multiple validation errors
// returned by ListRequest.ValidateAll() if the designated constraints aren't met.
type ListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRequestMultiError) AllErrors() []error { return m }

// ListRequestValidationError is the validation error returned by
// ListRequest.Validate if the designated constraints aren't met.
type ListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRequestValidationError) ErrorName() string { return "ListRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRequestValidationError{}

// Validate checks the field values on RoleRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleRequestMultiError, or
// nil if none found.
func (m *RoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Sort

	// no validation rules for Status

	// no validation rules for Hidden

	// no validation rules for Description

	// no validation rules for CreatorId

	for idx, item := range m.GetRoleMenus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoleRequestValidationError{
						field:  fmt.Sprintf("RoleMenus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoleRequestValidationError{
						field:  fmt.Sprintf("RoleMenus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoleRequestValidationError{
					field:  fmt.Sprintf("RoleMenus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RoleRequestMultiError(errors)
	}

	return nil
}

// RoleRequestMultiError is an error wrapping multiple validation errors
// returned by RoleRequest.ValidateAll() if the designated constraints aren't met.
type RoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleRequestMultiError) AllErrors() []error { return m }

// RoleRequestValidationError is the validation error returned by
// RoleRequest.Validate if the designated constraints aren't met.
type RoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleRequestValidationError) ErrorName() string { return "RoleRequestValidationError" }

// Error satisfies the builtin error interface
func (e RoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleRequestValidationError{}

// Validate checks the field values on MenuRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuRequestMultiError, or
// nil if none found.
func (m *MenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ParentId

	// no validation rules for Router

	// no validation rules for Name

	// no validation rules for Component

	// no validation rules for Hidden

	// no validation rules for Keepalive

	// no validation rules for Sort

	// no validation rules for Status

	// no validation rules for Icon

	// no validation rules for Description

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuRequestValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuRequestValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuRequestValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuRequestMultiError(errors)
	}

	return nil
}

// MenuRequestMultiError is an error wrapping multiple validation errors
// returned by MenuRequest.ValidateAll() if the designated constraints aren't met.
type MenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuRequestMultiError) AllErrors() []error { return m }

// MenuRequestValidationError is the validation error returned by
// MenuRequest.Validate if the designated constraints aren't met.
type MenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuRequestValidationError) ErrorName() string { return "MenuRequestValidationError" }

// Error satisfies the builtin error interface
func (e MenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuRequestValidationError{}

// Validate checks the field values on TreeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TreeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TreeRequestMultiError, or
// nil if none found.
func (m *TreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	// no validation rules for PageSize

	// no validation rules for Status

	// no validation rules for Name

	// no validation rules for ParentId

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TreeRequestValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TreeRequestValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TreeRequestValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TreeRequestMultiError(errors)
	}

	return nil
}

// TreeRequestMultiError is an error wrapping multiple validation errors
// returned by TreeRequest.ValidateAll() if the designated constraints aren't met.
type TreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TreeRequestMultiError) AllErrors() []error { return m }

// TreeRequestValidationError is the validation error returned by
// TreeRequest.Validate if the designated constraints aren't met.
type TreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TreeRequestValidationError) ErrorName() string { return "TreeRequestValidationError" }

// Error satisfies the builtin error interface
func (e TreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TreeRequestValidationError{}

// Validate checks the field values on EmptyReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmptyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmptyReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmptyReplyMultiError, or
// nil if none found.
func (m *EmptyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *EmptyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyReplyMultiError(errors)
	}

	return nil
}

// EmptyReplyMultiError is an error wrapping multiple validation errors
// returned by EmptyReply.ValidateAll() if the designated constraints aren't met.
type EmptyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyReplyMultiError) AllErrors() []error { return m }

// EmptyReplyValidationError is the validation error returned by
// EmptyReply.Validate if the designated constraints aren't met.
type EmptyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyReplyValidationError) ErrorName() string { return "EmptyReplyValidationError" }

// Error satisfies the builtin error interface
func (e EmptyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmptyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyReplyValidationError{}

// Validate checks the field values on IDReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IDReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IDReply with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IDReplyMultiError, or nil if none found.
func (m *IDReply) ValidateAll() error {
	return m.validate(true)
}

func (m *IDReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return IDReplyMultiError(errors)
	}

	return nil
}

// IDReplyMultiError is an error wrapping multiple validation errors returned
// by IDReply.ValidateAll() if the designated constraints aren't met.
type IDReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IDReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IDReplyMultiError) AllErrors() []error { return m }

// IDReplyValidationError is the validation error returned by IDReply.Validate
// if the designated constraints aren't met.
type IDReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IDReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IDReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IDReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IDReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IDReplyValidationError) ErrorName() string { return "IDReplyValidationError" }

// Error satisfies the builtin error interface
func (e IDReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIDReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IDReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IDReplyValidationError{}

// Validate checks the field values on CaptchaReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CaptchaReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CaptchaReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CaptchaReplyMultiError, or
// nil if none found.
func (m *CaptchaReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CaptchaReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CaptchaId

	// no validation rules for PicPath

	if len(errors) > 0 {
		return CaptchaReplyMultiError(errors)
	}

	return nil
}

// CaptchaReplyMultiError is an error wrapping multiple validation errors
// returned by CaptchaReply.ValidateAll() if the designated constraints aren't met.
type CaptchaReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CaptchaReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CaptchaReplyMultiError) AllErrors() []error { return m }

// CaptchaReplyValidationError is the validation error returned by
// CaptchaReply.Validate if the designated constraints aren't met.
type CaptchaReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CaptchaReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CaptchaReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CaptchaReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CaptchaReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CaptchaReplyValidationError) ErrorName() string { return "CaptchaReplyValidationError" }

// Error satisfies the builtin error interface
func (e CaptchaReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCaptchaReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CaptchaReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CaptchaReplyValidationError{}

// Validate checks the field values on UserReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserReplyMultiError, or nil
// if none found.
func (m *UserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Username

	// no validation rules for Avatar

	// no validation rules for Email

	// no validation rules for Mobile

	// no validation rules for Nickname

	// no validation rules for Status

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetUserRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserReplyValidationError{
						field:  fmt.Sprintf("UserRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserReplyValidationError{
						field:  fmt.Sprintf("UserRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserReplyValidationError{
					field:  fmt.Sprintf("UserRoles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserReplyMultiError(errors)
	}

	return nil
}

// UserReplyMultiError is an error wrapping multiple validation errors returned
// by UserReply.ValidateAll() if the designated constraints aren't met.
type UserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserReplyMultiError) AllErrors() []error { return m }

// UserReplyValidationError is the validation error returned by
// UserReply.Validate if the designated constraints aren't met.
type UserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserReplyValidationError) ErrorName() string { return "UserReplyValidationError" }

// Error satisfies the builtin error interface
func (e UserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserReplyValidationError{}

// Validate checks the field values on ListUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListUserReplyMultiError, or
// nil if none found.
func (m *ListUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserReplyValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListUserReplyMultiError(errors)
	}

	return nil
}

// ListUserReplyMultiError is an error wrapping multiple validation errors
// returned by ListUserReply.ValidateAll() if the designated constraints
// aren't met.
type ListUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserReplyMultiError) AllErrors() []error { return m }

// ListUserReplyValidationError is the validation error returned by
// ListUserReply.Validate if the designated constraints aren't met.
type ListUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserReplyValidationError) ErrorName() string { return "ListUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserReplyValidationError{}

// Validate checks the field values on RoleReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleReplyMultiError, or nil
// if none found.
func (m *RoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Sort

	// no validation rules for Status

	// no validation rules for Description

	// no validation rules for CreatorId

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetRoleMenus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoleReplyValidationError{
						field:  fmt.Sprintf("RoleMenus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoleReplyValidationError{
						field:  fmt.Sprintf("RoleMenus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoleReplyValidationError{
					field:  fmt.Sprintf("RoleMenus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RoleReplyMultiError(errors)
	}

	return nil
}

// RoleReplyMultiError is an error wrapping multiple validation errors returned
// by RoleReply.ValidateAll() if the designated constraints aren't met.
type RoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleReplyMultiError) AllErrors() []error { return m }

// RoleReplyValidationError is the validation error returned by
// RoleReply.Validate if the designated constraints aren't met.
type RoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleReplyValidationError) ErrorName() string { return "RoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e RoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleReplyValidationError{}

// Validate checks the field values on ListRoleReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListRoleReplyMultiError, or
// nil if none found.
func (m *ListRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRoleReplyValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRoleReplyValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRoleReplyValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListRoleReplyMultiError(errors)
	}

	return nil
}

// ListRoleReplyMultiError is an error wrapping multiple validation errors
// returned by ListRoleReply.ValidateAll() if the designated constraints
// aren't met.
type ListRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleReplyMultiError) AllErrors() []error { return m }

// ListRoleReplyValidationError is the validation error returned by
// ListRoleReply.Validate if the designated constraints aren't met.
type ListRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleReplyValidationError) ErrorName() string { return "ListRoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleReplyValidationError{}

// Validate checks the field values on MenuReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuReplyMultiError, or nil
// if none found.
func (m *MenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ParentId

	// no validation rules for Path

	// no validation rules for Name

	// no validation rules for Hidden

	// no validation rules for Component

	// no validation rules for Sort

	// no validation rules for Status

	// no validation rules for Icon

	// no validation rules for CreatorId

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuReplyValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuReplyValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuReplyValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuReplyMultiError(errors)
	}

	return nil
}

// MenuReplyMultiError is an error wrapping multiple validation errors returned
// by MenuReply.ValidateAll() if the designated constraints aren't met.
type MenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuReplyMultiError) AllErrors() []error { return m }

// MenuReplyValidationError is the validation error returned by
// MenuReply.Validate if the designated constraints aren't met.
type MenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuReplyValidationError) ErrorName() string { return "MenuReplyValidationError" }

// Error satisfies the builtin error interface
func (e MenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuReplyValidationError{}

// Validate checks the field values on ListMenuReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListMenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMenuReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListMenuReplyMultiError, or
// nil if none found.
func (m *ListMenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMenuReplyValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMenuReplyValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMenuReplyValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListMenuReplyMultiError(errors)
	}

	return nil
}

// ListMenuReplyMultiError is an error wrapping multiple validation errors
// returned by ListMenuReply.ValidateAll() if the designated constraints
// aren't met.
type ListMenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMenuReplyMultiError) AllErrors() []error { return m }

// ListMenuReplyValidationError is the validation error returned by
// ListMenuReply.Validate if the designated constraints aren't met.
type ListMenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMenuReplyValidationError) ErrorName() string { return "ListMenuReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListMenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMenuReplyValidationError{}

// Validate checks the field values on RegisterReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReplyMultiError, or
// nil if none found.
func (m *RegisterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Username

	if len(errors) > 0 {
		return RegisterReplyMultiError(errors)
	}

	return nil
}

// RegisterReplyMultiError is an error wrapping multiple validation errors
// returned by RegisterReply.ValidateAll() if the designated constraints
// aren't met.
type RegisterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReplyMultiError) AllErrors() []error { return m }

// RegisterReplyValidationError is the validation error returned by
// RegisterReply.Validate if the designated constraints aren't met.
type RegisterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReplyValidationError) ErrorName() string { return "RegisterReplyValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReplyValidationError{}

// Validate checks the field values on LoginReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReplyMultiError, or
// nil if none found.
func (m *LoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginReplyValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserId

	// no validation rules for Username

	if len(errors) > 0 {
		return LoginReplyMultiError(errors)
	}

	return nil
}

// LoginReplyMultiError is an error wrapping multiple validation errors
// returned by LoginReply.ValidateAll() if the designated constraints aren't met.
type LoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReplyMultiError) AllErrors() []error { return m }

// LoginReplyValidationError is the validation error returned by
// LoginReply.Validate if the designated constraints aren't met.
type LoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReplyValidationError) ErrorName() string { return "LoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReplyValidationError{}

// Validate checks the field values on UploadReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UploadReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UploadReplyMultiError, or
// nil if none found.
func (m *UploadReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if len(errors) > 0 {
		return UploadReplyMultiError(errors)
	}

	return nil
}

// UploadReplyMultiError is an error wrapping multiple validation errors
// returned by UploadReply.ValidateAll() if the designated constraints aren't met.
type UploadReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadReplyMultiError) AllErrors() []error { return m }

// UploadReplyValidationError is the validation error returned by
// UploadReply.Validate if the designated constraints aren't met.
type UploadReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadReplyValidationError) ErrorName() string { return "UploadReplyValidationError" }

// Error satisfies the builtin error interface
func (e UploadReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadReplyValidationError{}

// Validate checks the field values on MenuTreeReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuTreeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuTreeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuTreeReplyMultiError, or
// nil if none found.
func (m *MenuTreeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuTreeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ParentId

	// no validation rules for Path

	// no validation rules for Name

	// no validation rules for Component

	// no validation rules for Hidden

	// no validation rules for Sort

	// no validation rules for Status

	// no validation rules for Icon

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuTreeReplyValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuTreeReplyValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuTreeReplyValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuTreeReplyValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuTreeReplyValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuTreeReplyValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuTreeReplyMultiError(errors)
	}

	return nil
}

// MenuTreeReplyMultiError is an error wrapping multiple validation errors
// returned by MenuTreeReply.ValidateAll() if the designated constraints
// aren't met.
type MenuTreeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuTreeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuTreeReplyMultiError) AllErrors() []error { return m }

// MenuTreeReplyValidationError is the validation error returned by
// MenuTreeReply.Validate if the designated constraints aren't met.
type MenuTreeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuTreeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuTreeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuTreeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuTreeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuTreeReplyValidationError) ErrorName() string { return "MenuTreeReplyValidationError" }

// Error satisfies the builtin error interface
func (e MenuTreeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuTreeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuTreeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuTreeReplyValidationError{}

// Validate checks the field values on UserRoleID with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserRoleID) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRoleID with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserRoleIDMultiError, or
// nil if none found.
func (m *UserRoleID) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRoleID) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for RoleId

	if len(errors) > 0 {
		return UserRoleIDMultiError(errors)
	}

	return nil
}

// UserRoleIDMultiError is an error wrapping multiple validation errors
// returned by UserRoleID.ValidateAll() if the designated constraints aren't met.
type UserRoleIDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRoleIDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRoleIDMultiError) AllErrors() []error { return m }

// UserRoleIDValidationError is the validation error returned by
// UserRoleID.Validate if the designated constraints aren't met.
type UserRoleIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRoleIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRoleIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRoleIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRoleIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRoleIDValidationError) ErrorName() string { return "UserRoleIDValidationError" }

// Error satisfies the builtin error interface
func (e UserRoleIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRoleID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRoleIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRoleIDValidationError{}

// Validate checks the field values on UserRole with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserRole) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRole with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserRoleMultiError, or nil
// if none found.
func (m *UserRole) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRole) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Sort

	// no validation rules for Status

	// no validation rules for Description

	// no validation rules for CreatorId

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetRoleMenus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserRoleValidationError{
						field:  fmt.Sprintf("RoleMenus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserRoleValidationError{
						field:  fmt.Sprintf("RoleMenus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserRoleValidationError{
					field:  fmt.Sprintf("RoleMenus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserRoleMultiError(errors)
	}

	return nil
}

// UserRoleMultiError is an error wrapping multiple validation errors returned
// by UserRole.ValidateAll() if the designated constraints aren't met.
type UserRoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRoleMultiError) AllErrors() []error { return m }

// UserRoleValidationError is the validation error returned by
// UserRole.Validate if the designated constraints aren't met.
type UserRoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRoleValidationError) ErrorName() string { return "UserRoleValidationError" }

// Error satisfies the builtin error interface
func (e UserRoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRoleValidationError{}

// Validate checks the field values on RoleMenu with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleMenu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleMenu with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleMenuMultiError, or nil
// if none found.
func (m *RoleMenu) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleMenu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RoleId

	// no validation rules for MenuId

	// no validation rules for ActionId

	if len(errors) > 0 {
		return RoleMenuMultiError(errors)
	}

	return nil
}

// RoleMenuMultiError is an error wrapping multiple validation errors returned
// by RoleMenu.ValidateAll() if the designated constraints aren't met.
type RoleMenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleMenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleMenuMultiError) AllErrors() []error { return m }

// RoleMenuValidationError is the validation error returned by
// RoleMenu.Validate if the designated constraints aren't met.
type RoleMenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleMenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleMenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleMenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleMenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleMenuValidationError) ErrorName() string { return "RoleMenuValidationError" }

// Error satisfies the builtin error interface
func (e RoleMenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleMenu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleMenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleMenuValidationError{}

// Validate checks the field values on TokenData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TokenData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TokenDataMultiError, or nil
// if none found.
func (m *TokenData) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for ExpiresAt

	// no validation rules for TokenType

	if len(errors) > 0 {
		return TokenDataMultiError(errors)
	}

	return nil
}

// TokenDataMultiError is an error wrapping multiple validation errors returned
// by TokenData.ValidateAll() if the designated constraints aren't met.
type TokenDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenDataMultiError) AllErrors() []error { return m }

// TokenDataValidationError is the validation error returned by
// TokenData.Validate if the designated constraints aren't met.
type TokenDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenDataValidationError) ErrorName() string { return "TokenDataValidationError" }

// Error satisfies the builtin error interface
func (e TokenDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenDataValidationError{}

// Validate checks the field values on QueryOption with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryOption with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryOptionMultiError, or
// nil if none found.
func (m *QueryOption) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Keyword

	// no validation rules for Column

	// no validation rules for Sort

	if len(errors) > 0 {
		return QueryOptionMultiError(errors)
	}

	return nil
}

// QueryOptionMultiError is an error wrapping multiple validation errors
// returned by QueryOption.ValidateAll() if the designated constraints aren't met.
type QueryOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryOptionMultiError) AllErrors() []error { return m }

// QueryOptionValidationError is the validation error returned by
// QueryOption.Validate if the designated constraints aren't met.
type QueryOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryOptionValidationError) ErrorName() string { return "QueryOptionValidationError" }

// Error satisfies the builtin error interface
func (e QueryOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryOptionValidationError{}

// Validate checks the field values on MenuAction with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuAction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuActionMultiError, or
// nil if none found.
func (m *MenuAction) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for MenuId

	// no validation rules for Name

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuActionValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuActionValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuActionValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuActionMultiError(errors)
	}

	return nil
}

// MenuActionMultiError is an error wrapping multiple validation errors
// returned by MenuAction.ValidateAll() if the designated constraints aren't met.
type MenuActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuActionMultiError) AllErrors() []error { return m }

// MenuActionValidationError is the validation error returned by
// MenuAction.Validate if the designated constraints aren't met.
type MenuActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuActionValidationError) ErrorName() string { return "MenuActionValidationError" }

// Error satisfies the builtin error interface
func (e MenuActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuActionValidationError{}

// Validate checks the field values on MenuActionResource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MenuActionResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuActionResource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MenuActionResourceMultiError, or nil if none found.
func (m *MenuActionResource) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuActionResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ActionId

	// no validation rules for Method

	// no validation rules for Path

	if len(errors) > 0 {
		return MenuActionResourceMultiError(errors)
	}

	return nil
}

// MenuActionResourceMultiError is an error wrapping multiple validation errors
// returned by MenuActionResource.ValidateAll() if the designated constraints
// aren't met.
type MenuActionResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuActionResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuActionResourceMultiError) AllErrors() []error { return m }

// MenuActionResourceValidationError is the validation error returned by
// MenuActionResource.Validate if the designated constraints aren't met.
type MenuActionResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuActionResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuActionResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuActionResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuActionResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuActionResourceValidationError) ErrorName() string {
	return "MenuActionResourceValidationError"
}

// Error satisfies the builtin error interface
func (e MenuActionResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuActionResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuActionResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuActionResourceValidationError{}

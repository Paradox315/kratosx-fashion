// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/system/v1/system.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on EmptyRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmptyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmptyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmptyRequestMultiError, or
// nil if none found.
func (m *EmptyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EmptyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyRequestMultiError(errors)
	}

	return nil
}

// EmptyRequestMultiError is an error wrapping multiple validation errors
// returned by EmptyRequest.ValidateAll() if the designated constraints aren't met.
type EmptyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyRequestMultiError) AllErrors() []error { return m }

// EmptyRequestValidationError is the validation error returned by
// EmptyRequest.Validate if the designated constraints aren't met.
type EmptyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyRequestValidationError) ErrorName() string { return "EmptyRequestValidationError" }

// Error satisfies the builtin error interface
func (e EmptyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmptyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyRequestValidationError{}

// Validate checks the field values on RegisterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterRequestMultiError, or nil if none found.
func (m *RegisterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RegisterRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := RegisterRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RegisterRequest_Password_Pattern.MatchString(m.GetPassword()) {
		err := RegisterRequestValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^[a-zA-Z]\\\\w{5,17}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = RegisterRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetMobile()) > 11 {
		err := RegisterRequestValidationError{
			field:  "Mobile",
			reason: "value length must be at most 11 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RegisterRequest_Mobile_Pattern.MatchString(m.GetMobile()) {
		err := RegisterRequestValidationError{
			field:  "Mobile",
			reason: "value does not match regex pattern \"^1(3|4|5|6|7|8|9)\\\\d{9}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCaptcha()) > 6 {
		err := RegisterRequestValidationError{
			field:  "Captcha",
			reason: "value length must be at most 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CaptchaId

	if len(errors) > 0 {
		return RegisterRequestMultiError(errors)
	}

	return nil
}

func (m *RegisterRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *RegisterRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// RegisterRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterRequest.ValidateAll() if the designated constraints
// aren't met.
type RegisterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterRequestMultiError) AllErrors() []error { return m }

// RegisterRequestValidationError is the validation error returned by
// RegisterRequest.Validate if the designated constraints aren't met.
type RegisterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterRequestValidationError) ErrorName() string { return "RegisterRequestValidationError" }

// Error satisfies the builtin error interface
func (e RegisterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterRequestValidationError{}

var _RegisterRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{4,15}$")

var _RegisterRequest_Password_Pattern = regexp.MustCompile("^[a-zA-Z]\\w{5,17}$")

var _RegisterRequest_Mobile_Pattern = regexp.MustCompile("^1(3|4|5|6|7|8|9)\\d{9}$")

// Validate checks the field values on RetrieveRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RetrieveRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetrieveRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetrieveRequestMultiError, or nil if none found.
func (m *RetrieveRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RetrieveRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RetrieveRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := RetrieveRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCaptcha()) > 6 {
		err := RetrieveRequestValidationError{
			field:  "Captcha",
			reason: "value length must be at most 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CaptchaId

	if len(errors) > 0 {
		return RetrieveRequestMultiError(errors)
	}

	return nil
}

// RetrieveRequestMultiError is an error wrapping multiple validation errors
// returned by RetrieveRequest.ValidateAll() if the designated constraints
// aren't met.
type RetrieveRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetrieveRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetrieveRequestMultiError) AllErrors() []error { return m }

// RetrieveRequestValidationError is the validation error returned by
// RetrieveRequest.Validate if the designated constraints aren't met.
type RetrieveRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetrieveRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetrieveRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetrieveRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetrieveRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetrieveRequestValidationError) ErrorName() string { return "RetrieveRequestValidationError" }

// Error satisfies the builtin error interface
func (e RetrieveRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetrieveRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetrieveRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetrieveRequestValidationError{}

var _RetrieveRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{4,15}$")

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_LoginRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := LoginRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_LoginRequest_Password_Pattern.MatchString(m.GetPassword()) {
		err := LoginRequestValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^[a-zA-Z]\\\\w{5,17}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCaptcha()) > 6 {
		err := LoginRequestValidationError{
			field:  "Captcha",
			reason: "value length must be at most 6 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CaptchaId

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

var _LoginRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{4,15}$")

var _LoginRequest_Password_Pattern = regexp.MustCompile("^[a-zA-Z]\\w{5,17}$")

// Validate checks the field values on UserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserRequestMultiError, or
// nil if none found.
func (m *UserRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if !_UserRequest_Username_Pattern.MatchString(m.GetUsername()) {
		err := UserRequestValidationError{
			field:  "Username",
			reason: "value does not match regex pattern \"^[a-zA-Z][a-zA-Z0-9_]{4,15}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UserRequest_Password_Pattern.MatchString(m.GetPassword()) {
		err := UserRequestValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^[a-zA-Z]\\\\w{5,17}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Avatar

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = UserRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetMobile()) > 11 {
		err := UserRequestValidationError{
			field:  "Mobile",
			reason: "value length must be at most 11 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UserRequest_Mobile_Pattern.MatchString(m.GetMobile()) {
		err := UserRequestValidationError{
			field:  "Mobile",
			reason: "value does not match regex pattern \"^1(3|4|5|6|7|8|9)\\\\d{9}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Gender

	// no validation rules for Status

	for idx, item := range m.GetUserRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserRequestValidationError{
						field:  fmt.Sprintf("UserRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserRequestValidationError{
						field:  fmt.Sprintf("UserRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserRequestValidationError{
					field:  fmt.Sprintf("UserRoles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserRequestMultiError(errors)
	}

	return nil
}

func (m *UserRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *UserRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UserRequestMultiError is an error wrapping multiple validation errors
// returned by UserRequest.ValidateAll() if the designated constraints aren't met.
type UserRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRequestMultiError) AllErrors() []error { return m }

// UserRequestValidationError is the validation error returned by
// UserRequest.Validate if the designated constraints aren't met.
type UserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRequestValidationError) ErrorName() string { return "UserRequestValidationError" }

// Error satisfies the builtin error interface
func (e UserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRequestValidationError{}

var _UserRequest_Username_Pattern = regexp.MustCompile("^[a-zA-Z][a-zA-Z0-9_]{4,15}$")

var _UserRequest_Password_Pattern = regexp.MustCompile("^[a-zA-Z]\\w{5,17}$")

var _UserRequest_Mobile_Pattern = regexp.MustCompile("^1(3|4|5|6|7|8|9)\\d{9}$")

// Validate checks the field values on IDRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IDRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IDRequestMultiError, or nil
// if none found.
func (m *IDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return IDRequestMultiError(errors)
	}

	return nil
}

// IDRequestMultiError is an error wrapping multiple validation errors returned
// by IDRequest.ValidateAll() if the designated constraints aren't met.
type IDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IDRequestMultiError) AllErrors() []error { return m }

// IDRequestValidationError is the validation error returned by
// IDRequest.Validate if the designated constraints aren't met.
type IDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IDRequestValidationError) ErrorName() string { return "IDRequestValidationError" }

// Error satisfies the builtin error interface
func (e IDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IDRequestValidationError{}

// Validate checks the field values on IDsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IDsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IDsRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IDsRequestMultiError, or
// nil if none found.
func (m *IDsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IDsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ids

	if len(errors) > 0 {
		return IDsRequestMultiError(errors)
	}

	return nil
}

// IDsRequestMultiError is an error wrapping multiple validation errors
// returned by IDsRequest.ValidateAll() if the designated constraints aren't met.
type IDsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IDsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IDsRequestMultiError) AllErrors() []error { return m }

// IDsRequestValidationError is the validation error returned by
// IDsRequest.Validate if the designated constraints aren't met.
type IDsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IDsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IDsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IDsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IDsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IDsRequestValidationError) ErrorName() string { return "IDsRequestValidationError" }

// Error satisfies the builtin error interface
func (e IDsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIDsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IDsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IDsRequestValidationError{}

// Validate checks the field values on StatusRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatusRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatusRequestMultiError, or
// nil if none found.
func (m *StatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Status

	if len(errors) > 0 {
		return StatusRequestMultiError(errors)
	}

	return nil
}

// StatusRequestMultiError is an error wrapping multiple validation errors
// returned by StatusRequest.ValidateAll() if the designated constraints
// aren't met.
type StatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusRequestMultiError) AllErrors() []error { return m }

// StatusRequestValidationError is the validation error returned by
// StatusRequest.Validate if the designated constraints aren't met.
type StatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusRequestValidationError) ErrorName() string { return "StatusRequestValidationError" }

// Error satisfies the builtin error interface
func (e StatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusRequestValidationError{}

// Validate checks the field values on PasswordRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PasswordRequestMultiError, or nil if none found.
func (m *PasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for OldPassword

	// no validation rules for NewPassword

	if len(errors) > 0 {
		return PasswordRequestMultiError(errors)
	}

	return nil
}

// PasswordRequestMultiError is an error wrapping multiple validation errors
// returned by PasswordRequest.ValidateAll() if the designated constraints
// aren't met.
type PasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordRequestMultiError) AllErrors() []error { return m }

// PasswordRequestValidationError is the validation error returned by
// PasswordRequest.Validate if the designated constraints aren't met.
type PasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordRequestValidationError) ErrorName() string { return "PasswordRequestValidationError" }

// Error satisfies the builtin error interface
func (e PasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordRequestValidationError{}

// Validate checks the field values on ListRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListRequestMultiError, or
// nil if none found.
func (m *ListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	if m.GetPageSize() > 50 {
		err := ListRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 50",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListRequestMultiError(errors)
	}

	return nil
}

// ListRequestMultiError is an error wrapping multiple validation errors
// returned by ListRequest.ValidateAll() if the designated constraints aren't met.
type ListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRequestMultiError) AllErrors() []error { return m }

// ListRequestValidationError is the validation error returned by
// ListRequest.Validate if the designated constraints aren't met.
type ListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRequestValidationError) ErrorName() string { return "ListRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRequestValidationError{}

// Validate checks the field values on ListSearchRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListSearchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSearchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSearchRequestMultiError, or nil if none found.
func (m *ListSearchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSearchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNum

	if m.GetPageSize() > 50 {
		err := ListSearchRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 50",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetQuery() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSearchRequestValidationError{
						field:  fmt.Sprintf("Query[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSearchRequestValidationError{
						field:  fmt.Sprintf("Query[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSearchRequestValidationError{
					field:  fmt.Sprintf("Query[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListSearchRequestMultiError(errors)
	}

	return nil
}

// ListSearchRequestMultiError is an error wrapping multiple validation errors
// returned by ListSearchRequest.ValidateAll() if the designated constraints
// aren't met.
type ListSearchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSearchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSearchRequestMultiError) AllErrors() []error { return m }

// ListSearchRequestValidationError is the validation error returned by
// ListSearchRequest.Validate if the designated constraints aren't met.
type ListSearchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSearchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSearchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSearchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSearchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSearchRequestValidationError) ErrorName() string {
	return "ListSearchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSearchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSearchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSearchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSearchRequestValidationError{}

// Validate checks the field values on RoleRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleRequestMultiError, or
// nil if none found.
func (m *RoleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	for idx, item := range m.GetRoleResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoleRequestValidationError{
						field:  fmt.Sprintf("RoleResources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoleRequestValidationError{
						field:  fmt.Sprintf("RoleResources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoleRequestValidationError{
					field:  fmt.Sprintf("RoleResources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RoleRequestMultiError(errors)
	}

	return nil
}

// RoleRequestMultiError is an error wrapping multiple validation errors
// returned by RoleRequest.ValidateAll() if the designated constraints aren't met.
type RoleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleRequestMultiError) AllErrors() []error { return m }

// RoleRequestValidationError is the validation error returned by
// RoleRequest.Validate if the designated constraints aren't met.
type RoleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleRequestValidationError) ErrorName() string { return "RoleRequestValidationError" }

// Error satisfies the builtin error interface
func (e RoleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleRequestValidationError{}

// Validate checks the field values on MenuRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuRequestMultiError, or
// nil if none found.
func (m *MenuRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ParentId

	// no validation rules for Path

	// no validation rules for Name

	// no validation rules for Component

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuRequestValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Hidden

	// no validation rules for Keepalive

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuRequestValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuRequestValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuRequestValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuRequestMultiError(errors)
	}

	return nil
}

// MenuRequestMultiError is an error wrapping multiple validation errors
// returned by MenuRequest.ValidateAll() if the designated constraints aren't met.
type MenuRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuRequestMultiError) AllErrors() []error { return m }

// MenuRequestValidationError is the validation error returned by
// MenuRequest.Validate if the designated constraints aren't met.
type MenuRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuRequestValidationError) ErrorName() string { return "MenuRequestValidationError" }

// Error satisfies the builtin error interface
func (e MenuRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuRequestValidationError{}

// Validate checks the field values on TreeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TreeRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TreeRequestMultiError, or
// nil if none found.
func (m *TreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if len(errors) > 0 {
		return TreeRequestMultiError(errors)
	}

	return nil
}

// TreeRequestMultiError is an error wrapping multiple validation errors
// returned by TreeRequest.ValidateAll() if the designated constraints aren't met.
type TreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TreeRequestMultiError) AllErrors() []error { return m }

// TreeRequestValidationError is the validation error returned by
// TreeRequest.Validate if the designated constraints aren't met.
type TreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TreeRequestValidationError) ErrorName() string { return "TreeRequestValidationError" }

// Error satisfies the builtin error interface
func (e TreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TreeRequestValidationError{}

// Validate checks the field values on EmptyReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmptyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmptyReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmptyReplyMultiError, or
// nil if none found.
func (m *EmptyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *EmptyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EmptyReplyMultiError(errors)
	}

	return nil
}

// EmptyReplyMultiError is an error wrapping multiple validation errors
// returned by EmptyReply.ValidateAll() if the designated constraints aren't met.
type EmptyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmptyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmptyReplyMultiError) AllErrors() []error { return m }

// EmptyReplyValidationError is the validation error returned by
// EmptyReply.Validate if the designated constraints aren't met.
type EmptyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmptyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmptyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmptyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmptyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmptyReplyValidationError) ErrorName() string { return "EmptyReplyValidationError" }

// Error satisfies the builtin error interface
func (e EmptyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmptyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmptyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmptyReplyValidationError{}

// Validate checks the field values on IDReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IDReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IDReply with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IDReplyMultiError, or nil if none found.
func (m *IDReply) ValidateAll() error {
	return m.validate(true)
}

func (m *IDReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return IDReplyMultiError(errors)
	}

	return nil
}

// IDReplyMultiError is an error wrapping multiple validation errors returned
// by IDReply.ValidateAll() if the designated constraints aren't met.
type IDReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IDReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IDReplyMultiError) AllErrors() []error { return m }

// IDReplyValidationError is the validation error returned by IDReply.Validate
// if the designated constraints aren't met.
type IDReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IDReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IDReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IDReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IDReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IDReplyValidationError) ErrorName() string { return "IDReplyValidationError" }

// Error satisfies the builtin error interface
func (e IDReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIDReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IDReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IDReplyValidationError{}

// Validate checks the field values on CaptchaReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CaptchaReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CaptchaReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CaptchaReplyMultiError, or
// nil if none found.
func (m *CaptchaReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CaptchaReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CaptchaId

	// no validation rules for PicPath

	if len(errors) > 0 {
		return CaptchaReplyMultiError(errors)
	}

	return nil
}

// CaptchaReplyMultiError is an error wrapping multiple validation errors
// returned by CaptchaReply.ValidateAll() if the designated constraints aren't met.
type CaptchaReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CaptchaReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CaptchaReplyMultiError) AllErrors() []error { return m }

// CaptchaReplyValidationError is the validation error returned by
// CaptchaReply.Validate if the designated constraints aren't met.
type CaptchaReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CaptchaReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CaptchaReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CaptchaReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CaptchaReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CaptchaReplyValidationError) ErrorName() string { return "CaptchaReplyValidationError" }

// Error satisfies the builtin error interface
func (e CaptchaReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCaptchaReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CaptchaReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CaptchaReplyValidationError{}

// Validate checks the field values on RoutePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RoutePolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoutePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RoutePolicyRequestMultiError, or nil if none found.
func (m *RoutePolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RoutePolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetRouters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoutePolicyRequestValidationError{
						field:  fmt.Sprintf("Routers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoutePolicyRequestValidationError{
						field:  fmt.Sprintf("Routers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoutePolicyRequestValidationError{
					field:  fmt.Sprintf("Routers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RoutePolicyRequestMultiError(errors)
	}

	return nil
}

// RoutePolicyRequestMultiError is an error wrapping multiple validation errors
// returned by RoutePolicyRequest.ValidateAll() if the designated constraints
// aren't met.
type RoutePolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoutePolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoutePolicyRequestMultiError) AllErrors() []error { return m }

// RoutePolicyRequestValidationError is the validation error returned by
// RoutePolicyRequest.Validate if the designated constraints aren't met.
type RoutePolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoutePolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoutePolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoutePolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoutePolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoutePolicyRequestValidationError) ErrorName() string {
	return "RoutePolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RoutePolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoutePolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoutePolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoutePolicyRequestValidationError{}

// Validate checks the field values on UserReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserReplyMultiError, or nil
// if none found.
func (m *UserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Username

	// no validation rules for Avatar

	// no validation rules for Email

	// no validation rules for Mobile

	// no validation rules for Nickname

	// no validation rules for Gender

	// no validation rules for Status

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetUserRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserReplyValidationError{
						field:  fmt.Sprintf("UserRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserReplyValidationError{
						field:  fmt.Sprintf("UserRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserReplyValidationError{
					field:  fmt.Sprintf("UserRoles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserReplyMultiError(errors)
	}

	return nil
}

// UserReplyMultiError is an error wrapping multiple validation errors returned
// by UserReply.ValidateAll() if the designated constraints aren't met.
type UserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserReplyMultiError) AllErrors() []error { return m }

// UserReplyValidationError is the validation error returned by
// UserReply.Validate if the designated constraints aren't met.
type UserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserReplyValidationError) ErrorName() string { return "UserReplyValidationError" }

// Error satisfies the builtin error interface
func (e UserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserReplyValidationError{}

// Validate checks the field values on ListUserReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListUserReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListUserReplyMultiError, or
// nil if none found.
func (m *ListUserReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListUserReplyValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListUserReplyValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListUserReplyMultiError(errors)
	}

	return nil
}

// ListUserReplyMultiError is an error wrapping multiple validation errors
// returned by ListUserReply.ValidateAll() if the designated constraints
// aren't met.
type ListUserReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserReplyMultiError) AllErrors() []error { return m }

// ListUserReplyValidationError is the validation error returned by
// ListUserReply.Validate if the designated constraints aren't met.
type ListUserReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserReplyValidationError) ErrorName() string { return "ListUserReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListUserReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserReplyValidationError{}

// Validate checks the field values on RoleReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleReplyMultiError, or nil
// if none found.
func (m *RoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Description

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetRoleResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RoleReplyValidationError{
						field:  fmt.Sprintf("RoleResources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RoleReplyValidationError{
						field:  fmt.Sprintf("RoleResources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RoleReplyValidationError{
					field:  fmt.Sprintf("RoleResources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RoleReplyMultiError(errors)
	}

	return nil
}

// RoleReplyMultiError is an error wrapping multiple validation errors returned
// by RoleReply.ValidateAll() if the designated constraints aren't met.
type RoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleReplyMultiError) AllErrors() []error { return m }

// RoleReplyValidationError is the validation error returned by
// RoleReply.Validate if the designated constraints aren't met.
type RoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleReplyValidationError) ErrorName() string { return "RoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e RoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleReplyValidationError{}

// Validate checks the field values on ListRoleReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListRoleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRoleReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListRoleReplyMultiError, or
// nil if none found.
func (m *ListRoleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRoleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRoleReplyValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRoleReplyValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRoleReplyValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListRoleReplyMultiError(errors)
	}

	return nil
}

// ListRoleReplyMultiError is an error wrapping multiple validation errors
// returned by ListRoleReply.ValidateAll() if the designated constraints
// aren't met.
type ListRoleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRoleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRoleReplyMultiError) AllErrors() []error { return m }

// ListRoleReplyValidationError is the validation error returned by
// ListRoleReply.Validate if the designated constraints aren't met.
type ListRoleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRoleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRoleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRoleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRoleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRoleReplyValidationError) ErrorName() string { return "ListRoleReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListRoleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRoleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRoleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRoleReplyValidationError{}

// Validate checks the field values on MenuReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuReplyMultiError, or nil
// if none found.
func (m *MenuReply) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTree() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuReplyValidationError{
						field:  fmt.Sprintf("Tree[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuReplyValidationError{
						field:  fmt.Sprintf("Tree[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuReplyValidationError{
					field:  fmt.Sprintf("Tree[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuReplyMultiError(errors)
	}

	return nil
}

// MenuReplyMultiError is an error wrapping multiple validation errors returned
// by MenuReply.ValidateAll() if the designated constraints aren't met.
type MenuReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuReplyMultiError) AllErrors() []error { return m }

// MenuReplyValidationError is the validation error returned by
// MenuReply.Validate if the designated constraints aren't met.
type MenuReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuReplyValidationError) ErrorName() string { return "MenuReplyValidationError" }

// Error satisfies the builtin error interface
func (e MenuReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuReplyValidationError{}

// Validate checks the field values on RegisterReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterReplyMultiError, or
// nil if none found.
func (m *RegisterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Username

	if len(errors) > 0 {
		return RegisterReplyMultiError(errors)
	}

	return nil
}

// RegisterReplyMultiError is an error wrapping multiple validation errors
// returned by RegisterReply.ValidateAll() if the designated constraints
// aren't met.
type RegisterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterReplyMultiError) AllErrors() []error { return m }

// RegisterReplyValidationError is the validation error returned by
// RegisterReply.Validate if the designated constraints aren't met.
type RegisterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterReplyValidationError) ErrorName() string { return "RegisterReplyValidationError" }

// Error satisfies the builtin error interface
func (e RegisterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterReplyValidationError{}

// Validate checks the field values on LoginReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReplyMultiError, or
// nil if none found.
func (m *LoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetToken()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginReplyValidationError{
					field:  "Token",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetToken()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginReplyValidationError{
				field:  "Token",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserId

	// no validation rules for Username

	if len(errors) > 0 {
		return LoginReplyMultiError(errors)
	}

	return nil
}

// LoginReplyMultiError is an error wrapping multiple validation errors
// returned by LoginReply.ValidateAll() if the designated constraints aren't met.
type LoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReplyMultiError) AllErrors() []error { return m }

// LoginReplyValidationError is the validation error returned by
// LoginReply.Validate if the designated constraints aren't met.
type LoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReplyValidationError) ErrorName() string { return "LoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReplyValidationError{}

// Validate checks the field values on UploadReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UploadReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UploadReplyMultiError, or
// nil if none found.
func (m *UploadReply) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if len(errors) > 0 {
		return UploadReplyMultiError(errors)
	}

	return nil
}

// UploadReplyMultiError is an error wrapping multiple validation errors
// returned by UploadReply.ValidateAll() if the designated constraints aren't met.
type UploadReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadReplyMultiError) AllErrors() []error { return m }

// UploadReplyValidationError is the validation error returned by
// UploadReply.Validate if the designated constraints aren't met.
type UploadReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadReplyValidationError) ErrorName() string { return "UploadReplyValidationError" }

// Error satisfies the builtin error interface
func (e UploadReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadReplyValidationError{}

// Validate checks the field values on RouterReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RouterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RouterReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RouterReplyMultiError, or
// nil if none found.
func (m *RouterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RouterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRouters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouterReplyValidationError{
						field:  fmt.Sprintf("Routers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouterReplyValidationError{
						field:  fmt.Sprintf("Routers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouterReplyValidationError{
					field:  fmt.Sprintf("Routers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RouterReplyMultiError(errors)
	}

	return nil
}

// RouterReplyMultiError is an error wrapping multiple validation errors
// returned by RouterReply.ValidateAll() if the designated constraints aren't met.
type RouterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RouterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RouterReplyMultiError) AllErrors() []error { return m }

// RouterReplyValidationError is the validation error returned by
// RouterReply.Validate if the designated constraints aren't met.
type RouterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RouterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RouterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RouterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RouterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RouterReplyValidationError) ErrorName() string { return "RouterReplyValidationError" }

// Error satisfies the builtin error interface
func (e RouterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRouterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RouterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RouterReplyValidationError{}

// Validate checks the field values on UserRoleID with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserRoleID) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRoleID with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserRoleIDMultiError, or
// nil if none found.
func (m *UserRoleID) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRoleID) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for RoleId

	if len(errors) > 0 {
		return UserRoleIDMultiError(errors)
	}

	return nil
}

// UserRoleIDMultiError is an error wrapping multiple validation errors
// returned by UserRoleID.ValidateAll() if the designated constraints aren't met.
type UserRoleIDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRoleIDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRoleIDMultiError) AllErrors() []error { return m }

// UserRoleIDValidationError is the validation error returned by
// UserRoleID.Validate if the designated constraints aren't met.
type UserRoleIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRoleIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRoleIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRoleIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRoleIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRoleIDValidationError) ErrorName() string { return "UserRoleIDValidationError" }

// Error satisfies the builtin error interface
func (e UserRoleIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRoleID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRoleIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRoleIDValidationError{}

// Validate checks the field values on UserRole with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserRole) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserRole with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserRoleMultiError, or nil
// if none found.
func (m *UserRole) ValidateAll() error {
	return m.validate(true)
}

func (m *UserRole) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	if len(errors) > 0 {
		return UserRoleMultiError(errors)
	}

	return nil
}

// UserRoleMultiError is an error wrapping multiple validation errors returned
// by UserRole.ValidateAll() if the designated constraints aren't met.
type UserRoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserRoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserRoleMultiError) AllErrors() []error { return m }

// UserRoleValidationError is the validation error returned by
// UserRole.Validate if the designated constraints aren't met.
type UserRoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserRoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserRoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserRoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserRoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserRoleValidationError) ErrorName() string { return "UserRoleValidationError" }

// Error satisfies the builtin error interface
func (e UserRoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserRoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserRoleValidationError{}

// Validate checks the field values on RoleResource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleResource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleResourceMultiError, or
// nil if none found.
func (m *RoleResource) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RoleId

	// no validation rules for ResourceId

	// no validation rules for ResourceType

	if len(errors) > 0 {
		return RoleResourceMultiError(errors)
	}

	return nil
}

// RoleResourceMultiError is an error wrapping multiple validation errors
// returned by RoleResource.ValidateAll() if the designated constraints aren't met.
type RoleResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleResourceMultiError) AllErrors() []error { return m }

// RoleResourceValidationError is the validation error returned by
// RoleResource.Validate if the designated constraints aren't met.
type RoleResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleResourceValidationError) ErrorName() string { return "RoleResourceValidationError" }

// Error satisfies the builtin error interface
func (e RoleResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleResourceValidationError{}

// Validate checks the field values on Token with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Token) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Token with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TokenMultiError, or nil if none found.
func (m *Token) ValidateAll() error {
	return m.validate(true)
}

func (m *Token) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for ExpiresAt

	// no validation rules for TokenType

	if len(errors) > 0 {
		return TokenMultiError(errors)
	}

	return nil
}

// TokenMultiError is an error wrapping multiple validation errors returned by
// Token.ValidateAll() if the designated constraints aren't met.
type TokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenMultiError) AllErrors() []error { return m }

// TokenValidationError is the validation error returned by Token.Validate if
// the designated constraints aren't met.
type TokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenValidationError) ErrorName() string { return "TokenValidationError" }

// Error satisfies the builtin error interface
func (e TokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenValidationError{}

// Validate checks the field values on Menu with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Menu) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Menu with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MenuMultiError, or nil if none found.
func (m *Menu) ValidateAll() error {
	return m.validate(true)
}

func (m *Menu) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ParentId

	// no validation rules for Path

	// no validation rules for Name

	// no validation rules for Component

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MenuValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MenuValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Hidden

	// no validation rules for Keepalive

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MenuValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MenuValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MenuMultiError(errors)
	}

	return nil
}

// MenuMultiError is an error wrapping multiple validation errors returned by
// Menu.ValidateAll() if the designated constraints aren't met.
type MenuMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuMultiError) AllErrors() []error { return m }

// MenuValidationError is the validation error returned by Menu.Validate if the
// designated constraints aren't met.
type MenuValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuValidationError) ErrorName() string { return "MenuValidationError" }

// Error satisfies the builtin error interface
func (e MenuValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenu.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuValidationError{}

// Validate checks the field values on MenuAction with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuAction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuActionMultiError, or
// nil if none found.
func (m *MenuAction) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Name

	if len(errors) > 0 {
		return MenuActionMultiError(errors)
	}

	return nil
}

// MenuActionMultiError is an error wrapping multiple validation errors
// returned by MenuAction.ValidateAll() if the designated constraints aren't met.
type MenuActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuActionMultiError) AllErrors() []error { return m }

// MenuActionValidationError is the validation error returned by
// MenuAction.Validate if the designated constraints aren't met.
type MenuActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuActionValidationError) ErrorName() string { return "MenuActionValidationError" }

// Error satisfies the builtin error interface
func (e MenuActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuActionValidationError{}

// Validate checks the field values on MenuMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MenuMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MenuMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MenuMetaMultiError, or nil
// if none found.
func (m *MenuMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *MenuMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Locale

	// no validation rules for RequireAuth

	// no validation rules for Icon

	// no validation rules for Order

	if len(errors) > 0 {
		return MenuMetaMultiError(errors)
	}

	return nil
}

// MenuMetaMultiError is an error wrapping multiple validation errors returned
// by MenuMeta.ValidateAll() if the designated constraints aren't met.
type MenuMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MenuMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MenuMetaMultiError) AllErrors() []error { return m }

// MenuMetaValidationError is the validation error returned by
// MenuMeta.Validate if the designated constraints aren't met.
type MenuMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MenuMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MenuMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MenuMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MenuMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MenuMetaValidationError) ErrorName() string { return "MenuMetaValidationError" }

// Error satisfies the builtin error interface
func (e MenuMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMenuMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MenuMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MenuMetaValidationError{}

// Validate checks the field values on QueryOption with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryOption with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryOptionMultiError, or
// nil if none found.
func (m *QueryOption) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Opt

	// no validation rules for Value

	if all {
		switch v := interface{}(m.GetInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryOptionValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryOptionValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryOptionValidationError{
				field:  "Interval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Field

	// no validation rules for Desc

	if len(errors) > 0 {
		return QueryOptionMultiError(errors)
	}

	return nil
}

// QueryOptionMultiError is an error wrapping multiple validation errors
// returned by QueryOption.ValidateAll() if the designated constraints aren't met.
type QueryOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryOptionMultiError) AllErrors() []error { return m }

// QueryOptionValidationError is the validation error returned by
// QueryOption.Validate if the designated constraints aren't met.
type QueryOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryOptionValidationError) ErrorName() string { return "QueryOptionValidationError" }

// Error satisfies the builtin error interface
func (e QueryOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryOptionValidationError{}

// Validate checks the field values on Router with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Router) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Router with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RouterMultiError, or nil if none found.
func (m *Router) ValidateAll() error {
	return m.validate(true)
}

func (m *Router) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	// no validation rules for Method

	// no validation rules for Name

	// no validation rules for Owned

	if len(errors) > 0 {
		return RouterMultiError(errors)
	}

	return nil
}

// RouterMultiError is an error wrapping multiple validation errors returned by
// Router.ValidateAll() if the designated constraints aren't met.
type RouterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RouterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RouterMultiError) AllErrors() []error { return m }

// RouterValidationError is the validation error returned by Router.Validate if
// the designated constraints aren't met.
type RouterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RouterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RouterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RouterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RouterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RouterValidationError) ErrorName() string { return "RouterValidationError" }

// Error satisfies the builtin error interface
func (e RouterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRouter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RouterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RouterValidationError{}

// Validate checks the field values on RouterGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RouterGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RouterGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RouterGroupMultiError, or
// nil if none found.
func (m *RouterGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *RouterGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	// no validation rules for Name

	// no validation rules for Owned

	for idx, item := range m.GetRouter() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RouterGroupValidationError{
						field:  fmt.Sprintf("Router[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RouterGroupValidationError{
						field:  fmt.Sprintf("Router[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RouterGroupValidationError{
					field:  fmt.Sprintf("Router[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RouterGroupMultiError(errors)
	}

	return nil
}

// RouterGroupMultiError is an error wrapping multiple validation errors
// returned by RouterGroup.ValidateAll() if the designated constraints aren't met.
type RouterGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RouterGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RouterGroupMultiError) AllErrors() []error { return m }

// RouterGroupValidationError is the validation error returned by
// RouterGroup.Validate if the designated constraints aren't met.
type RouterGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RouterGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RouterGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RouterGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RouterGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RouterGroupValidationError) ErrorName() string { return "RouterGroupValidationError" }

// Error satisfies the builtin error interface
func (e RouterGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRouterGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RouterGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RouterGroupValidationError{}

// Validate checks the field values on QueryOption_Interval with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryOption_Interval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryOption_Interval with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryOption_IntervalMultiError, or nil if none found.
func (m *QueryOption_Interval) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryOption_Interval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for To

	if len(errors) > 0 {
		return QueryOption_IntervalMultiError(errors)
	}

	return nil
}

// QueryOption_IntervalMultiError is an error wrapping multiple validation
// errors returned by QueryOption_Interval.ValidateAll() if the designated
// constraints aren't met.
type QueryOption_IntervalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryOption_IntervalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryOption_IntervalMultiError) AllErrors() []error { return m }

// QueryOption_IntervalValidationError is the validation error returned by
// QueryOption_Interval.Validate if the designated constraints aren't met.
type QueryOption_IntervalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryOption_IntervalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryOption_IntervalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryOption_IntervalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryOption_IntervalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryOption_IntervalValidationError) ErrorName() string {
	return "QueryOption_IntervalValidationError"
}

// Error satisfies the builtin error interface
func (e QueryOption_IntervalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryOption_Interval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryOption_IntervalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryOption_IntervalValidationError{}
